<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teach Me How To Scream</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
			background-color: #000000;
        }
		
		@font-face {
			font-family: 'Deathcore';
			src: url('fonts/Faceless.ttf') format('truetype');
		}

		@font-face {
			font-family: 'Crunk';
			src: url('fonts/TheDark.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Eagle Horizon';
			src: url('fonts/EagleHorizon.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Sakana';
			src: url('fonts/Sakana.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Reckless';
			src: url('fonts/ERODED.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Sketch';
			src: url('fonts/Shockwave.ttf') format('truetype');
		}
		@font-face {
			font-family: 'Cursive1';
			src: url('fonts/Yellowtail-Regular.ttf') format('truetype');
		}
		
		
        div#content-1 {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000000;
			
        }
        div#nav-bar {
            position: fixed;
            width: 100%;
            height: 50px;
            background-color: #131313;
            border-bottom: solid 1px #ff0000;
        }
        select {
            border-radius: 15px;
            border: 2px solid #ffffff;
            color: #ffffff;
            background-color: #000000;
            width: 150px;
            height: 36px;
            margin-top: 9px;
            margin-left: 20px;
        }
        img#profile-picture {
			margin-top: 30px;
            width: 350px;
            height: 300px;
			border: 1px solid #ffffff;
        }
        audio {
            height: 45px;
            border-radius: 0px;
            border: 2px solid #ffffff;
            background-color: #131313;
        }
        canvas {
            width: 48%;
            height: 135px;
            display: block;
            background-color: #000000;
        }
        #controls {
            position: absolute;
            bottom: 193px;
            right: 30px;
        }
        button {
            margin-left: 10px;
            padding: 10px;
            background-color: #ff0000;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #cc0000;
        }
        .info {
			font-family: Arial;
            position: absolute;
            width: 320px;
            height: 180px; /* Adjusted height to fit the gain */
            background-color: #808080;
            color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
        }
        #info-artist {
            bottom: 235px;
            left: 30px;
        }
        #info-user {
            bottom: 235px;
            right: 30px;
        }
		
		div#bio {
			float: left;
		}
		div#name-info {
			margin-left: 30px;
			font-size: 30px;
			font-family: Deathcore;
			color: #ffffff;
		
		}
		div#band-info {
			margin-left: 28px;
			font-size: 20px;
			font-family: Arial;
			color: #ffffff;
		
		}
		div#lyrics {
			position: absolute;
			top: 270px;
			left: 500px;
			width: 930px;
			height: 445px;
			border-radius: 15px;
			background-color: #131313;
			color: #ffffff;
			font-family: Sakana;
			font-size: 26px;
		}
		
		div#banner {
			position: absolute;
			color: #ffffff;
			font-size: 28px;
			font-family: Crunk;
			left: 825px;
			top: 10px;
		
		
		}
		
		hr {
			display: block;
			height: 1px;
			border: 0;
			border-top: 2px solid #000000;
			margin: 1em 0;
			padding: 0;
		}
		
		#factoid {
			position: absolute; 
			left:500px;
			top:85px;
			background-color: #131313;
			width: 895px;
			height: 125px;
			border-radius: 15px;
            color: #ffffff;
            padding: 20px;
			font-family: Cursive1;
            text-align: center;
            font-size: 1.7rem;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        
		}
		
		#search-container {
            position: relative;
            width: 10px;
            height: 30px;
        }

        #search-bar {
            width: 165px;
            height: 35px;
			margin-left: 5px;
			margin-top: 10px;
            background-color: #1f1f1f;
            border: 1px solid #ffffff;
            border-radius: 15px;
            color: #ffffff;
            padding: 0 10px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            outline: none;
        }

        #search-results {
            position: absolute;
            top: 50px;
            left: 0px;
            width: 400px;
            max-height: 200px;
            background-color: #1f1f1f;
            border: 1px solid #ffffff;
            border-radius: 5px;
            overflow-y: auto;
            padding: 10px;
            display: none;
        }

        .result-item {
            padding: 5px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            font-family: Arial, sans-serif;
        }

        .result-item:hover {
            background-color: #333333;
        }

        .no-matches {
            text-align: center;
            font-size: 14px;
            font-family: Arial, sans-serif;
            color: #ffffff;
        }
		div#lesson-controls {
		
			position: absolute;
			top: 0px;
			margin-left: 160px;
		
		}
		#options-pane-two {
			position: absolute;
			right: 150px;
			top: 10px;
		}
		.hyperlinks {
			position: relative;
			margin-right: 50px;
			font-size: 20px;
			font-family: Eagle Horizon;
			color: #ffffff;
			text-decoration: none;
		}
		.hyperlinks:hover {
			color: #535353;
		}
    </style>
</head>
<body>
    <div id='content-1'>
        <div id='nav-bar'>
			<div id="search-container">
				<input type="text" id="search-bar" placeholder="Search Artists">
            <div id="search-results"></div>
			</div>
			<div id='lesson-controls'>
            <select id='lesson'>
                <option>Lesson 1</option>
                <option>Fry Lesson 1</option>
                <option>False Chord Lesson 1</option>
            </select>
			<select id='vocal-song'>
                <option>Sample 1</option>
                <option>Sample 2</option>
                <option>Sample 3</option>
            </select>
            <button id="generateSampleBtn">Random Artist</button>
            <button id="downloadSampleBtn">Download Sample</button>
			</div>
			<div id='banner'>Teach Me How To Scream AI</div>
			<div id='options-pane-two'>
				<a href='tutorial.html' target='_blank' class='hyperlinks'>Tutorials</a>
				<a href='faq.html' target='_blank' class='hyperlinks'>F.A.Q</a>
				<a href='about.html' target='_blank' class='hyperlinks'>About</a>
				<a href='contact.html' target='_blank' class='hyperlinks'>Contact</a>
				<a href='labs.html' target='_blank' class='hyperlinks'><img style='position: absolute; top: 7px; height:25px; width:20px;' src='gfx/labs.png' alt='labs' /></a>
			</div>
			<div style='position: absolute; right: 10px; top: -5px;'><img style='width: 98px; height: 55px;' src='gfx/paypal.png' /></div>
        </div>
		
        <br>
        <div style='margin-top: 20px;margin-left: 10px;'>
            <img id='profile-picture' src='profile_pics/CJ_McCreery.jpg'>
        </div>
		<div id='bio'>
			<div id='name-info'>
				Alex Terrible
			</div>
			<div id='band-info'>
				Bands: Slaughter to Prevail
			</div>
		</div>
		
        <div id="controls">
            <button id="recordBtn">Record</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="downloadBtn" disabled>Download</button>
			<button id="compareBtn">Compare Audio</button>
        </div>
        <div style='position: absolute; bottom: 5px;width:100%;left: 30px;'>
            <canvas style='margin-left: 932px; margin-bottom: -135px;' id='canvas-user'></canvas>
            <canvas style='margin-left: 2px;' id='canvas-artist'></canvas>
            <audio id='artist-audio' style='width:48%;' src='samples/false_chord/alex_terrible/sample-1.mp3' controls></audio>
            <audio id='user-audio' style='width:48%;' src='samples/false_chord/alex_terrible/sample-1.mp3' controls></audio>
        </div>
        
        <!-- Updated divs for displaying audio info, including gain -->
        <div id="info-artist" class="info">
            <strong>Artist Audio:</strong>
            <div id="dB-artist">dB: </div>
            <div id="fundamental-artist">Fundamental Frequency: </div>
            <div id="harmonics-artist">Harmonics: </div>
            <div id="pitch-artist">Pitch: </div>
            <div id="key-artist">Key: </div>
            <div id="gain-artist">Gain: </div>
			<div id="distortion-artist">Distortion: </div>
        </div>
		<a style='position: absolute; left: 30px; top: 722px;' href='#' name='unheart' onclick='javascript: heartUnheart()'><img id='fav' style='width: 35px; height: 35px;' src='gfx/unheart.png' /></a>
		<a id='metronome' style='position: absolute; left: 70px; top: 722px;' href='#'><img style='width: 35px; height: 35px;' src='gfx/metro.png' /></a>
		<input id='bpms' type='text' style='position: absolute; top: 727px; left: 117px; width: 70px; height: 34px; border-radius: 10px; color:#ffffff; border: 2px solid #ffffff; background-color: #1f1f1f;' placeholder='Enter BPM'></input>
		<select style='position: absolute; left: 175px; top: 716px;' id="select-visual">
			<option value="spectrum">Bars (Frequency Spectrum)</option>
			<option value="waveform">Waveform (Oscilloscope)</option>
		</select>
        <div id="info-user" class="info">
            <strong>User Audio:</strong>
            <div id="dB-user">dB: </div>
            <div id="fundamental-user">Fundamental Frequency: </div>
            <div id="harmonics-user">Harmonics: </div>
            <div id="pitch-user">Pitch: </div>
            <div id="key-user">Key: </div>
            <div id="gain-user">Gain: </div>
			<div id="distortion-user">Distortion: </div>
        </div>
		<div id='factoid'>Welcome!!!</div>
		<div id='lyrics'>
			<div style='margin-top: 20px;'>
				<center>Hell is right here! You've been abandoned, you've been abandoned! Hell is right here! Kingdom of storm and thunder</center>
				<br>
				<hr>
				<div style='position: absolute; left: 20px; font-size: 20px;' id='automated-response'></div>
					<div id="score-container" style="width: 300px; margin-left: 20px; font-size: 20px; color: #ffffff; margin-bottom: 8px;"></div>
					<div id="rating-container" style="width: 300px; margin-left: 20px; font-size: 20px; color: #ffffff; margin-bottom: 8px;"></div>
					<div style='width: 900px;  overflow-y: scroll; margin-left: 20px;'><div id="feedback-container" style="font-size: 16px; height: 150px; color: #ffffff; line-height: 1.5;"></div></div>	
			</div>
		</div>
		<div style='position: absolute; top: 100px; right: 60px;' id='ad-1'>
			<img style='width: 300px; height: 357px;' src='gfx/ad.png' />
		</div>
    </div>

<script>

        const metronomeButton = document.getElementById('metronome');
        const bpmInput = document.getElementById('bpms');

        let audioContext = null;
        let tickingInterval = null;
        let bpm = 100;

        function createTick() {
            // Initialize the AudioContext if it doesn't exist
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const oscillator = audioContext.createOscillator(); // Create a new oscillator
            const gainNode = audioContext.createGain(); // Create a gain node to control volume

            oscillator.type = 'square'; // Generate a square wave (tick-like sound)
            oscillator.frequency.value = 1000; // Set the frequency to 1000 Hz (adjustable)

            gainNode.gain.setValueAtTime(1, audioContext.currentTime); // Full volume
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1); // Fade out quickly

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1); // Stop the oscillator after 0.1 seconds
        }

        function startMetronome() {
            const interval = 60000 / bpm; // Calculate interval in milliseconds
            tickingInterval = setInterval(createTick, interval); // Schedule ticks
        }

        function stopMetronome() {
            clearInterval(tickingInterval); // Clear the interval
            tickingInterval = null;
        }

        metronomeButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (tickingInterval) {
                stopMetronome();
            } else {
                startMetronome();
            }
        });

        bpmInput.addEventListener('input', () => {
            const newBpm = parseInt(bpmInput.value, 10);
            bpm = isNaN(newBpm) || newBpm <= 0 ? 100 : newBpm; // Default to 100 if invalid
            if (tickingInterval) {
                stopMetronome();
                startMetronome(); // Restart the metronome with the new BPM
            }
        });

function heartUnheart() {
		
		const favStatus = document.getElementById('fav');
		if (favStatus.getAttribute('src') == 'gfx/unheart.png') {
			favStatus.src = 'gfx/heart.png';
			
		}
		else if (favStatus.getAttribute('src') == 'gfx/heart.png') {
				favStatus.src = 'gfx/unheart.png';
			
		}
}



window.onload = function () {



		
		const searchBar = document.getElementById('search-bar');
        const searchResults = document.getElementById('search-results');

        const dummyData = [
            { id: 1, name: 'Alex Terrible' },
            { id: 2, name: 'Will Ramos' },
            { id: 3, name: 'Danny Worsnop' },
            { id: 4, name: 'CJ McCreery' },
            { id: 5, name: 'Lorna Shore' },
            { id: 6, name: 'Slaughter to Prevail' },
        ];

        searchBar.addEventListener('input', function () {
            const query = this.value.trim().toLowerCase();

            if (query === '') {
                searchResults.style.display = 'none';
                return;
            }

            const filteredResults = dummyData.filter(item =>
                item.name.toLowerCase().includes(query)
            );

            searchResults.innerHTML = '';

            if (filteredResults.length > 0) {
                filteredResults.forEach(item => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'result-item';
                    resultItem.textContent = item.name;

                    // Add click event to result item
                    resultItem.addEventListener('click', () => {
                        alert(`You selected ${item.name}`);
                    });

                    searchResults.appendChild(resultItem);
                });
            } else {
                const noMatch = document.createElement('div');
                noMatch.className = 'no-matches';
                noMatch.textContent = 'No Matches Found';
                searchResults.appendChild(noMatch);
            }

            searchResults.style.display = 'block';
        });

        searchBar.addEventListener('blur', () => {
            setTimeout(() => {
                searchResults.style.display = 'none';
            }, 200);
        });
	
	    const jsonFilePath = './vocal_tips.json';
		
		// Update the factoid div with a random tip


        // Fetch and parse the JSON file
        async function fetchTips() {
            const response = await fetch(jsonFilePath);
            const tips = await response.json();
            return tips;
        }

        // Update the factoid div with a random tip
		async function updateFactoid() {
			const factoidDiv = document.getElementById('factoid');
			const tips = await fetchTips();

			function getRandomTip() {
				const randomIndex = Math.floor(Math.random() * tips.length);
				return tips[randomIndex].tip; // Access the 'tip' field
			}

            function showTip(tip) {
				factoidDiv.style.opacity = '1'; // Fade in
				factoidDiv.innerHTML = tip;
			}

			function hideTip() {
				factoidDiv.style.opacity = '0'; // Fade out
			}


			// Cycle tips every 15 seconds
			setInterval(() => {
				hideTip();
				setTimeout(() => {
					const randomTip = getRandomTip();
					showTip(randomTip);
				}, 1500); // Matches fade-out duration
			}, 10000); // Total cycle duration
		}

        // Initialize the factoid updates
        updateFactoid();
	
    let isRecording = false; // State for recording
    let mediaRecorder;
    let recordedChunks = [];

    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const userAudio = document.getElementById('user-audio');
    
    // Visualizer select (dropdown for waveform or bars)
    const selectVisual = document.getElementById('select-visual');

    // Audio elements
    const artistAudio = document.getElementById('artist-audio');
    const canvasArtist = document.getElementById('canvas-artist');
    const canvasUser = document.getElementById('canvas-user');
    const ctxArtist = canvasArtist.getContext('2d');
    const ctxUser = canvasUser.getContext('2d');
    
    // AudioContext setup
    const audioContextArtist = new (window.AudioContext || window.webkitAudioContext)();
    const analyserArtist = audioContextArtist.createAnalyser();
    const sourceArtist = audioContextArtist.createMediaElementSource(artistAudio);
    sourceArtist.connect(analyserArtist);
    analyserArtist.connect(audioContextArtist.destination);

    const bufferLengthArtist = analyserArtist.frequencyBinCount;
    const dataArrayArtist = new Uint8Array(bufferLengthArtist);
    analyserArtist.fftSize = 2048;

    const audioContextUser = new (window.AudioContext || window.webkitAudioContext)();
    const analyserUser = audioContextUser.createAnalyser();
    const sourceUser = audioContextUser.createMediaElementSource(userAudio);
    sourceUser.connect(analyserUser);
    analyserUser.connect(audioContextUser.destination);

    const bufferLengthUser = analyserUser.frequencyBinCount;
    const dataArrayUser = new Uint8Array(bufferLengthUser);
    analyserUser.fftSize = 2048;

    let isArtistPlaying = false;
    let isUserPlaying = false;
	
    selectVisual.addEventListener('change', draw); // Redraw on visualizer change
    
    // Helper function for gain calculation
    function calculateGain(dataArray) {
        const gain = Math.max(...dataArray) / 255;
        return gain >= 0.6 ? 1 : gain < 0.2 ? 0.05 : gain;
	}

    // Function to calculate and update audio info
    function calculateAudioSpecs(analyser, dataArray, bufferLength, infoPrefix) {
        analyser.getByteFrequencyData(dataArray);

        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i] ** 2;
        }
        const rms = Math.sqrt(sum / bufferLength);
        const dB = 20 * Math.log10(rms / 255);
        document.getElementById(`dB-${infoPrefix}`).innerText = `dB: ${dB.toFixed(2)}`;

        let maxIndex = 0;
        let maxValue = -Infinity;
        for (let i = 0; i < bufferLength; i++) {
            if (dataArray[i] > maxValue) {
                maxValue = dataArray[i];
                maxIndex = i;
            }
        }
        const fundamentalFreq = maxIndex * analyser.context.sampleRate / analyser.fftSize;
        document.getElementById(`fundamental-${infoPrefix}`).innerText = `Fundamental Frequency: ${fundamentalFreq.toFixed(2)} Hz`;

        const harmonics = maxValue / 255;
        document.getElementById(`harmonics-${infoPrefix}`).innerText = `Harmonics: ${harmonics.toFixed(2)}`;

        const pitch = fundamentalFreq;
        document.getElementById(`pitch-${infoPrefix}`).innerText = `Pitch: ${pitch.toFixed(2)} Hz`;

        const key = determineKey(fundamentalFreq);
        document.getElementById(`key-${infoPrefix}`).innerText = `Key: ${key}`;

        const gain = calculateGain(dataArray);
        document.getElementById(`gain-${infoPrefix}`).innerText = `Gain: ${gain.toFixed(2)}`;
    }

    // Function to draw waveform
    function drawWaveform(ctx, analyser, dataArray, bufferLength) {
        analyser.getByteTimeDomainData(dataArray);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);  // Clear previous frame
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#00ff00'; // Neon green color for waveform
        ctx.beginPath();

        for (let i = 0; i < bufferLength; i++) {
            const x = (i / bufferLength) * ctx.canvas.width; // Calculate the X position of each point
            const y = (dataArray[i] - 128) * 0.5 + ctx.canvas.height / 2; // Scale and center the Y values
            if (i === 0) {
                ctx.moveTo(x, y); // Start the path at the first point
            } else {
                ctx.lineTo(x, y); // Draw line to the next point
            }
        }
        ctx.stroke(); // Actually draw the path
    }

    // Function to draw bars
    function drawBars(ctx, analyser, dataArray, bufferLength) {
        analyser.getByteFrequencyData(dataArray);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);  // Clear previous frame
        ctx.fillStyle = '#ff0000'; // Color for frequency bars
        for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i] / 2;
            ctx.fillRect(i * 2, ctx.canvas.height - barHeight, 1, barHeight);
        }
    }

    // Function to draw visualization
    function draw() {
        const visualType = selectVisual.value; // Get selected visual type (waveform or bars)

        if (isArtistPlaying) {
            // Draw visualization for Artist
            if (visualType === 'waveform') {
                drawWaveform(ctxArtist, analyserArtist, dataArrayArtist, bufferLengthArtist);
            } else {
                drawBars(ctxArtist, analyserArtist, dataArrayArtist, bufferLengthArtist);
            }

            // Update artist audio info
            calculateAudioSpecs(analyserArtist, dataArrayArtist, bufferLengthArtist, 'artist');
		

        }

        if (isUserPlaying) {
            // Draw visualization for User
            if (visualType === 'waveform') {
                drawWaveform(ctxUser, analyserUser, dataArrayUser, bufferLengthUser);
            } else {
                drawBars(ctxUser, analyserUser, dataArrayUser, bufferLengthUser);
            }

            // Update user audio info
            calculateAudioSpecs(analyserUser, dataArrayUser, bufferLengthUser, 'user');
        }

        if (isArtistPlaying || isUserPlaying) {
            requestAnimationFrame(draw); // Keep drawing while playing
        }
    }

    // Play and pause controls for artist audio
    artistAudio.addEventListener('play', function () {
        isArtistPlaying = true;
        draw();
    });

    artistAudio.addEventListener('pause', function () {
        isArtistPlaying = false;
    });

    artistAudio.addEventListener('ended', function () {
        ctxArtist.clearRect(0, 0, canvasArtist.width, canvasArtist.height); // Clear canvas on audio end
        isArtistPlaying = false;
    });

    // Play and pause controls for user audio
    userAudio.addEventListener('play', function () {
        isUserPlaying = true;
        draw();
    });

    userAudio.addEventListener('pause', function () {
        isUserPlaying = false;
    });

    userAudio.addEventListener('ended', function () {
        ctxUser.clearRect(0, 0, canvasUser.width, canvasUser.height); // Clear canvas on audio end
        isUserPlaying = false;
    });

    // Recording functionality
recordBtn.addEventListener('click', function () {
    const automatedResponseDiv = document.getElementById('automated-response');
    let countdown = 5; // Starting countdown value

    // Countdown function
    function startCountdown() {
        if (countdown > 0) {
            automatedResponseDiv.innerText = countdown;
            countdown--;
            setTimeout(startCountdown, 1000); // Repeat every second
        } else {
            automatedResponseDiv.innerText = "GO!!!";

            // Start recording after countdown finishes
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                recordedChunks = []; // Reset recorded chunks
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.start();

                isRecording = true;
                recordBtn.disabled = true;
                stopBtn.disabled = false;

                // Stop recording when artist audio ends
                const artistAudio = document.getElementById('artist-audio');
                const duration = artistAudio.duration * 1000; // Convert seconds to milliseconds

                setTimeout(() => {
                    if (isRecording) {
                        mediaRecorder.stop();
                        isRecording = false;
                        recordBtn.disabled = false;
                        stopBtn.disabled = true;

                        automatedResponseDiv.innerText = "Recording Stopped!";
                    }
                }, duration);

                // Save audio data chunks
                mediaRecorder.ondataavailable = function (event) {
                    recordedChunks.push(event.data);
                };

                // Handle media recorder stop event
                mediaRecorder.onstop = function () {
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    userAudio.src = URL.createObjectURL(blob);
                    downloadBtn.disabled = false;

                    automatedResponseDiv.innerText = "Recording Complete!";
                };
            });
        }
    }

    // Start countdown
    startCountdown();
});

    stopBtn.addEventListener('click', function () {
        if (isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            recordBtn.disabled = false;
            stopBtn.disabled = true;
        }
    });

    // Download functionality
    downloadBtn.addEventListener('click', function () {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'recording.webm';
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
    });

}

// Buffers for storing artist and user audio chunks
let artistAudioChunks = [];
let userAudioChunks = [];
let isComparisonReady = false;

// Clear chunk data only at the start of a new comparison
function resetAudioChunksForComparison() {
    artistAudioChunks = [];
    userAudioChunks = [];
    isComparisonReady = false;
    console.log("Chunks reset for new comparison.");
}

// Function to process and store audio chunks for either artist or user
function processAudioChunks(analyser, bufferLength, dataArray) {
    const chunks = [];
    const interval = setInterval(() => {
        analyser.getByteFrequencyData(dataArray);
        chunks.push([...dataArray]); // Store a copy of current data
    }, 100); // Capture every 100ms
    return { stop: () => clearInterval(interval), getChunks: () => chunks };
}

    // Key determination based on frequency
    function determineKey(frequency) {
        const keys = [
            { note: "C", frequency: 261.63 }, { note: "C#", frequency: 277.18 }, { note: "D", frequency: 293.66 },
            { note: "D#", frequency: 311.13 }, { note: "E", frequency: 329.63 }, { note: "F", frequency: 349.23 },
            { note: "F#", frequency: 369.99 }, { note: "G", frequency: 392.00 }, { note: "G#", frequency: 415.30 },
            { note: "A", frequency: 440.00 }, { note: "A#", frequency: 466.16 }, { note: "B", frequency: 493.88 }
        ];
        let closestKey = keys[0].note;
        let closestFreqDiff = Math.abs(frequency - keys[0].frequency);
        keys.forEach(key => {
            const freqDiff = Math.abs(frequency - key.frequency);
            if (freqDiff < closestFreqDiff) {
                closestFreqDiff = freqDiff;
                closestKey = key.note;
            }
        });
        return closestKey;
    }


    // Circle of Fifths proximity score
    const circleOfFifths = ["C", "G", "D", "A", "E", "B", "F#", "C#", "G#", "D#", "A#", "F"];
    function getKeyProximityScore(artistKey, userKey) {
        const artistIndex = circleOfFifths.indexOf(artistKey);
        const userIndex = circleOfFifths.indexOf(userKey);
        if (artistIndex === -1 || userIndex === -1) return 0.05;
        const distance = Math.min(
            Math.abs(artistIndex - userIndex),
            12 - Math.abs(artistIndex - userIndex)
        );
        return distance <= 1.5 ? Math.max(0.05, 1 - distance * 0.2) : 0.05;
    }


// Function to calculate gain based on dataArray values
/*function calculateGain(dataArray) {
    const rms = Math.sqrt(dataArray.reduce((sum, val) => sum + val ** 2, 0) / dataArray.length);
    return rms / 255;
}*/
function calculateGain(dataArray) {
    const gain = Math.max(...dataArray) / 255;
    return gain >= 0.6 ? 1 : gain < 0.2 ? 0.05 : gain;
}

// Analyze artist audio
function analyzeArtistAudio() {
    const artistAudio = document.getElementById('artist-audio');
    const context = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = context.createAnalyser();
    const source = context.createMediaElementSource(artistAudio);
    source.connect(analyser);
    analyser.connect(context.destination);

    const processor = processAudioChunks(analyser, analyser.frequencyBinCount, new Uint8Array(analyser.frequencyBinCount));
    artistAudio.addEventListener('ended', () => {
        processor.stop();
        artistAudioChunks = processor.getChunks();
        console.log("Artist audio processing complete. Chunks collected:", artistAudioChunks.length);
        if (userAudioChunks.length > 0) isComparisonReady = true;
    });
}

// Analyze user audio
function analyzeUserAudio() {
    const userAudio = document.getElementById('user-audio');
    const context = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = context.createAnalyser();
    const source = context.createMediaElementSource(userAudio);
    source.connect(analyser);
    analyser.connect(context.destination);

    const processor = processAudioChunks(analyser, analyser.frequencyBinCount, new Uint8Array(analyser.frequencyBinCount));
    userAudio.addEventListener('ended', () => {
        processor.stop();
        userAudioChunks = processor.getChunks();
        console.log("User audio processing complete. Chunks collected:", userAudioChunks.length);
        if (artistAudioChunks.length > 0) isComparisonReady = true;
    });
}
	
	

function updateDistortionDisplay() {
    const distortion = calculateDistortion(dataArrayArtist, dataArrayUser);
    document.getElementById("distortion-artist").innerText = `Distortion: ${(distortion * 100).toFixed(2)}%`;
    document.getElementById("distortion-user").innerText = `Distortion: ${(distortion * 100).toFixed(2)}%`;
}

// Additional helper function to determine if keys are within a semitone
function isWithinSemitone(key1, key2) {
    // Define logic to check if keys are within one semitone, allowing slight tolerance
    const keyOrder = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const index1 = keyOrder.indexOf(key1);
    const index2 = keyOrder.indexOf(key2);

    // Ensure valid keys
    if (index1 === -1 || index2 === -1) return false;

    // Calculate absolute distance in key indices, wrapping around the circle of fifths
    const distance = Math.min(Math.abs(index1 - index2), 12 - Math.abs(index1 - index2));
    return distance <= 1; // Allow one semitone difference
}


async function generateDynamicFeedback(scores) {
    try {
        // Fetch the JSON file
        const response = await fetch('feedback_responses.json');
        const data = await response.json();

        // Placeholder for feedback
        const feedback = [];

        // Add opening response
        const openings = data.opening;
        feedback.push(openings[Math.floor(Math.random() * openings.length)]);

        // Add frequency feedback based on score
        const frequencyResponses = scores.frequency >= 0.8
            ? data.frequency.high
            : scores.frequency >= 0.6
            ? data.frequency.medium
            : data.frequency.low;
        feedback.push(frequencyResponses[Math.floor(Math.random() * frequencyResponses.length)]);

        // Add harmonics feedback based on score
        const harmonicsResponses = scores.harmonics >= 0.8
            ? data.harmonics.high
            : scores.harmonics >= 0.6
            ? data.harmonics.medium
            : data.harmonics.low;
        feedback.push(harmonicsResponses[Math.floor(Math.random() * harmonicsResponses.length)]);

        // Add key feedback based on score
        const keyResponses = scores.key >= 0.8
            ? data.key.high
            : scores.key >= 0.6
            ? data.key.medium
            : data.key.low;
        feedback.push(keyResponses[Math.floor(Math.random() * keyResponses.length)]);

        // Add distortion feedback based on score
        const distortionResponses = scores.distortion >= 0.8
            ? data.distortion.high
            : scores.distortion >= 0.6
            ? data.distortion.medium
            : data.distortion.low;
        feedback.push(distortionResponses[Math.floor(Math.random() * distortionResponses.length)]);

        // Add encouragement
        const encouragements = data.encouragement;
        feedback.push(encouragements[Math.floor(Math.random() * encouragements.length)]);

        // Return assembled feedback
        return feedback.join(" ");
    } catch (error) {
        console.error('Error loading feedback responses:', error);
        return "An error occurred while generating feedback.";
    }
}

 /*   feedback.push(responses.encouragement[Math.floor(Math.random() * responses.encouragement.length)]);

    // Return the assembled feedback
    return feedback.join(" ");
}*/

// Function to generate feedback based on score differences
	const automatedResponseDiv = document.getElementById('automated-response');
    function generateFeedback(totalFrequencyScore, totalHarmonicsScore, totalKeyScore, totalGainScore, totalDistortionScore) {
        let feedback = [];

        if (totalFrequencyScore < 0.7) feedback.push("Consider working on maintaining pitch consistency.");
        if (totalHarmonicsScore < 0.7) feedback.push("Harmonics could use some refinement for a cleaner sound.");
        if (totalKeyScore < 0.7) feedback.push("Try to stay closer to the key for a more harmonious match.");
        if (totalGainScore < 0.5) feedback.push("Your volume was a bit low, aim for a stronger presence.");
        if (totalDistortionScore < 0.6) feedback.push("Consider reducing distortion for clarity.");

        if (feedback.length === 0) feedback.push("Great job! You're closely aligned with the artist's performance.");

        return feedback.join(" ");
    }

    // Function to display feedback with a typing effect
    function displayTypedResponse(responseText, element) {
        let i = 0;
        element.innerHTML = "";
        function type() {
            if (i < responseText.length) {
                element.innerHTML += responseText.charAt(i);
                i++;
                setTimeout(type, 10); // Typing speed
            }
        }
        type();
    }

// Define response arrays for modular feedback generation
const initialPhrases = [
    "You could", "You can", "You have the potential to", "In this breakdown you",
    "With a bit more practice you could", "You are able to", "Your performance shows that",
    "The quality in your voice suggests", "With your current skill level,", "In this piece,"
];

const positiveFeedback = [
    "achieve strong vocal presence", "maintain steady pitch", "enhance resonance",
    "produce a warm and powerful sound", "stay perfectly in tune", "reach ideal gain levels",
    "hold stable frequency", "create impactful harmonics", "showcase balanced dynamics",
    "sustain clear vocal tone", "maintain excellent volume"
];

const areasForImprovement = [
    "focus on controlling pitch to avoid fluctuations", "aim for consistent harmonics",
    "work on reducing distortion for a cleaner sound", "try to keep closer to the key",
    "practice maintaining volume for a stronger presence", "work on holding steady gain levels"
];

const closingPhrases = [
    "Keep up the good work!", "Great progress so far!", "Nice work – keep going!",
    "You’re on the right path.", "Stay consistent and you’ll see improvements.",
    "Keep practicing for even greater results.", "You’re making solid progress!"
];

async function calculateFinalScore() {
    if (!isComparisonReady) {
        alert('Play both audios completely before comparing.');
        return;
    }

    let totalFrequencyScore = 0, totalHarmonicsScore = 0, totalKeyScore = 0, totalGainScore = 0, totalDistortionScore = 0;
    const minChunks = Math.min(artistAudioChunks.length, userAudioChunks.length);

    for (let i = 0; i < minChunks; i++) {
        const artistData = artistAudioChunks[i];
        const userData = userAudioChunks[i];

        // Perform calculations for scores
        const avgArtistFreq = artistData.reduce((a, b) => a + b, 0) / artistData.length;
        const avgUserFreq = userData.reduce((a, b) => a + b, 0) / userData.length;

        const frequencyDifference = Math.abs(avgArtistFreq - avgUserFreq);
        if (frequencyDifference < 0.5) {
            totalFrequencyScore += 1;
        } else if (frequencyDifference < 1.0) {
            totalFrequencyScore += 0.75;
        } else if (frequencyDifference < 1.5) {
            totalFrequencyScore += 0.5;
        }

        const harmonicsDifference = Math.abs(artistData[1] - userData[1]);
        if (harmonicsDifference < 0.05) {
            totalHarmonicsScore += 1;
        } else if (harmonicsDifference < 0.1) {
            totalHarmonicsScore += 0.75;
        } else if (harmonicsDifference < 0.2) {
            totalHarmonicsScore += 0.5;
        }

        const keyDifference = Math.abs(artistData[2] - userData[2]);
        if (keyDifference === 0) {
            totalKeyScore += 1;
        }

        const distortionDifference = Math.abs(artistData[4] - userData[4]);
        if (distortionDifference < 0.05) {
            totalDistortionScore += 1;
        } else if (distortionDifference < 0.1) {
            totalDistortionScore += 0.75;
        } else if (distortionDifference < 0.2) {
            totalDistortionScore += 0.5;
        }
    }

    // Normalize the scores
    const finalScores = {
        frequency: totalFrequencyScore / minChunks,
        harmonics: totalHarmonicsScore / minChunks,
        key: totalKeyScore / minChunks,
        distortion: totalDistortionScore / minChunks
    };

    const cappedFinalScore = Math.min((totalFrequencyScore + totalHarmonicsScore + totalKeyScore + totalDistortionScore) * 2 / 5, 10);

    // Generate feedback dynamically from the JSON file
    const feedback = await generateDynamicFeedback(finalScores);

    // Update the containers with the final results
    const scoreContainer = document.getElementById('score-container');
    const ratingContainer = document.getElementById('rating-container');
    const feedbackContainer = document.getElementById('feedback-container');

    // Calculate star rating
    let starRating = '★☆☆☆☆';
    if (cappedFinalScore >= 9) starRating = '★★★★★';
    else if (cappedFinalScore >= 7) starRating = '★★★★☆';
    else if (cappedFinalScore >= 5) starRating = '★★★☆☆';
    else if (cappedFinalScore >= 3) starRating = '★★☆☆☆';

    // Display results with typing effect
    displayTypedText(`Score: ${cappedFinalScore}/10`, 'score-container');
    displayTypedText(`Rating: ${starRating}`, 'rating-container');
    displayTypedText(feedback, 'feedback-container');
}
function displayTypedText(text, elementId) {
    const element = document.getElementById(elementId);
    let i = 0;
    element.innerHTML = ""; // Clear existing content

    function type() {
        if (i < text.length) {
            element.innerHTML += text.charAt(i);
            i++;
            setTimeout(type, 8); // Typing speed in milliseconds
        }
    }

    type();
}

    // Attach event listeners
    document.getElementById('compareBtn').addEventListener('click', calculateFinalScore);
    document.getElementById('artist-audio').addEventListener('play', analyzeArtistAudio);
    document.getElementById('user-audio').addEventListener('play', analyzeUserAudio);

</script>





</body>
</html>
